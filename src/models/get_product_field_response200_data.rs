/*
 * Pipedrive API v1
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

/// GetProductFieldResponse200Data : All data for the product field



#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetProductFieldResponse200Data {
    /// The name of the field
    #[serde(rename = "name")]
    pub name: String,
    /// When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array, for example:</br>`[{\"label\":\"red\"}, {\"label\":\"blue\"}, {\"label\":\"lilac\"}]`
    #[serde(rename = "options", skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<serde_json::Value>>,
    /// The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
    #[serde(rename = "field_type")]
    pub field_type: FieldType,
    /// The ID of the product field
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,
    /// The key of the product field
    #[serde(rename = "key", skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The position (index) of the product field in the detail view
    #[serde(rename = "order_nr", skip_serializing_if = "Option::is_none")]
    pub order_nr: Option<i32>,
    /// The product field creation time. Format: YYYY-MM-DD HH:MM:SS
    #[serde(rename = "add_time", skip_serializing_if = "Option::is_none")]
    pub add_time: Option<String>,
    /// The product field last update time. Format: YYYY-MM-DD HH:MM:SS
    #[serde(rename = "update_time", skip_serializing_if = "Option::is_none")]
    pub update_time: Option<String>,
    /// The ID of the last user to update the product field
    #[serde(rename = "last_updated_by_user_id", skip_serializing_if = "Option::is_none")]
    pub last_updated_by_user_id: Option<i32>,
    /// Whether or not the product field is currently active
    #[serde(rename = "active_flag", skip_serializing_if = "Option::is_none")]
    pub active_flag: Option<bool>,
    /// Whether or not the product field name and metadata is editable
    #[serde(rename = "edit_flag", skip_serializing_if = "Option::is_none")]
    pub edit_flag: Option<bool>,
    /// Whether or not the product field is visible in the Add Product Modal
    #[serde(rename = "add_visible_flag", skip_serializing_if = "Option::is_none")]
    pub add_visible_flag: Option<bool>,
    /// Whether or not the product field is marked as important
    #[serde(rename = "important_flag", skip_serializing_if = "Option::is_none")]
    pub important_flag: Option<bool>,
    /// Whether or not the product field data can be edited
    #[serde(rename = "bulk_edit_allowed", skip_serializing_if = "Option::is_none")]
    pub bulk_edit_allowed: Option<bool>,
    /// Whether or not the product field is searchable
    #[serde(rename = "searchable_flag", skip_serializing_if = "Option::is_none")]
    pub searchable_flag: Option<bool>,
    /// Whether or not the product field value can be used when filtering searches
    #[serde(rename = "filtering_allowed", skip_serializing_if = "Option::is_none")]
    pub filtering_allowed: Option<bool>,
    /// Whether or not the product field is sortable
    #[serde(rename = "sortable_flag", skip_serializing_if = "Option::is_none")]
    pub sortable_flag: Option<bool>,
    /// Whether or not the product field is mandatory when creating products
    #[serde(rename = "mandatory_flag", skip_serializing_if = "Option::is_none")]
    pub mandatory_flag: Option<bool>,
}

impl GetProductFieldResponse200Data {
    /// All data for the product field
    pub fn new(name: String, field_type: FieldType) -> GetProductFieldResponse200Data {
        GetProductFieldResponse200Data {
            name,
            options: None,
            field_type,
            id: None,
            key: None,
            order_nr: None,
            add_time: None,
            update_time: None,
            last_updated_by_user_id: None,
            active_flag: None,
            edit_flag: None,
            add_visible_flag: None,
            important_flag: None,
            bulk_edit_allowed: None,
            searchable_flag: None,
            filtering_allowed: None,
            sortable_flag: None,
            mandatory_flag: None,
        }
    }
}

/// The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum FieldType {
    #[serde(rename = "varchar")]
    Varchar,
    #[serde(rename = "varchar_auto")]
    VarcharAuto,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "double")]
    Double,
    #[serde(rename = "monetary")]
    Monetary,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "set")]
    Set,
    #[serde(rename = "enum")]
    Enum,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "org")]
    Org,
    #[serde(rename = "people")]
    People,
    #[serde(rename = "phone")]
    Phone,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "timerange")]
    Timerange,
    #[serde(rename = "daterange")]
    Daterange,
    #[serde(rename = "address")]
    Address,
}

impl Default for FieldType {
    fn default() -> FieldType {
        Self::Varchar
    }
}

